import{r as o,ht as N}from"./strapi-DJtumbce.js";const m=Symbol.for("react-redux-context"),g=typeof globalThis<"u"?globalThis:{};function Y(){var e;if(!o.createContext)return{};const r=(e=g[m])!=null?e:g[m]=new Map;let t=r.get(o.createContext);return t||(t=o.createContext(null),t.displayName="ReactRedux",r.set(o.createContext,t)),t}const h=Y();function k(e=h){return function(){const t=o.useContext(e);if(!t)throw new Error("could not find react-redux context value; please ensure the component is wrapped in a <Provider>");return t}}const j=k(),q=()=>{throw new Error("uSES not initialized!")};let b=q;const H=e=>{b=e},K=(e,r)=>e===r;function M(e=h){const r=e===h?j:k(e);return function(n,l={}){const{equalityFn:d=K,stabilityCheck:f=void 0,noopCheck:w=void 0}=typeof l=="function"?{equalityFn:l}:l;{if(!n)throw new Error("You must pass a selector to useSelector");if(typeof n!="function")throw new Error("You must pass a function as a selector to useSelector");if(typeof d!="function")throw new Error("You must pass a function as an equality function to useSelector")}const{store:x,subscription:E,getServerState:R,stabilityCheck:S,noopCheck:v}=r(),c=o.useRef(!0),z=o.useCallback({[n.name](s){const i=n(s);{const y=typeof f>"u"?S:f;if(y==="always"||y==="once"&&c.current){const a=n(s);if(!d(i,a)){let u;try{throw new Error}catch(T){({stack:u}=T)}console.warn("Selector "+(n.name||"unknown")+` returned a different result when called with the same parameters. This can lead to unnecessary rerenders.
Selectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization`,{state:s,selected:i,selected2:a,stack:u})}}const C=typeof w>"u"?v:w;if((C==="always"||C==="once"&&c.current)&&i===s){let a;try{throw new Error}catch(u){({stack:a}=u)}console.warn("Selector "+(n.name||"unknown")+` returned the root state when called. This can lead to unnecessary rerenders.
Selectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.`,{stack:a})}c.current&&(c.current=!1)}return i}}[n.name],[n,S,f]),p=b(E.addNestedSub,x.getState,R||x.getState,z,d);return o.useDebugValue(p),p}}const W=M();H(N.useSyncExternalStoreWithSelector);export{h as R,j as a,k as c,W as u};
