import{r,ht as N}from"./strapi-DJtumbce.js";const g=Symbol.for("react-redux-context"),k=typeof globalThis<"u"?globalThis:{};function $(){var e;if(!r.createContext)return{};const n=(e=k[g])!=null?e:k[g]=new Map;let o=n.get(r.createContext);return o||(o=r.createContext(null),o.displayName="ReactRedux",n.set(r.createContext,o)),o}const a=$();function p(e=a){return function(){const o=r.useContext(e);if(!o)throw new Error("could not find react-redux context value; please ensure the component is wrapped in a <Provider>");return o}}const b=p(),Y=()=>{throw new Error("uSES not initialized!")};let E=Y;const j=e=>{E=e},q=(e,n)=>e===n;function K(e=a){const n=e===a?b:p(e);return function(t,d={}){const{equalityFn:f=q,stabilityCheck:h=void 0,noopCheck:S=void 0}=typeof d=="function"?{equalityFn:d}:d;{if(!t)throw new Error("You must pass a selector to useSelector");if(typeof t!="function")throw new Error("You must pass a function as a selector to useSelector");if(typeof f!="function")throw new Error("You must pass a function as an equality function to useSelector")}const{store:w,subscription:v,getServerState:T,stabilityCheck:x,noopCheck:z}=n(),c=r.useRef(!0),D=r.useCallback({[t.name](u){const i=t(u);{const C=typeof h>"u"?x:h;if(C==="always"||C==="once"&&c.current){const s=t(u);if(!f(i,s)){let l;try{throw new Error}catch(H){({stack:l}=H)}console.warn("Selector "+(t.name||"unknown")+` returned a different result when called with the same parameters. This can lead to unnecessary rerenders.
Selectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization`,{state:u,selected:i,selected2:s,stack:l})}}const m=typeof S>"u"?z:S;if((m==="always"||m==="once"&&c.current)&&i===u){let s;try{throw new Error}catch(l){({stack:s}=l)}console.warn("Selector "+(t.name||"unknown")+` returned the root state when called. This can lead to unnecessary rerenders.
Selectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.`,{stack:s})}c.current&&(c.current=!1)}return i}}[t.name],[t,x,h]),y=E(v.addNestedSub,w.getState,T||w.getState,D,f);return r.useDebugValue(y),y}}const M=K();function R(e=a){const n=e===a?b:p(e);return function(){const{store:t}=n();return t}}const V=R();function W(e=a){const n=e===a?V:R(e);return function(){return n().dispatch}}const I=W();j(N.useSyncExternalStoreWithSelector);const U=I,_=M;export{U as a,_ as u};
